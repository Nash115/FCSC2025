# Analyse

Le flag est chiffré avec l'algorithme RSA, et on possède uniquement les valeurs de $n$, $e$ et $c$.

## Factorisation de $n$

Or on remarque que $e=3$, on peut alors tenter de **factoriser** $n$ avec `factorint()` de `sympy`


```py
from gmpy2 import powmod as pow
from sympy import factorint

N = 20828609401338794038836680655046788059251524928933537772275737490132096798900518851229365799426251400151127719543434160180496659560792762761336988343332946920310984844136554433346165529108260963140451576722579583104830933409454682160084747257400706214980238995436388944310800852033141986598424966358149711167942491331040747300866718813771865768701794983365111208518863175847678947437360554933091347604616653687980177405805542214635577758515398014710929022135522835744517328114492844837858920033569071591971676487452812830920525469634367387593309067794509735740140745616085618489218115494716811261406227449967579233657
E = 3
C = 6317668510138686569655374990729607736156413707292408158720036346854309670467296052918552527575331589363290061240725095262980389263184520673983411112154423282089471021996509038472493779143273789325774414352608726252566350689111876373836913240644190951995980896093509379920452743478551321978067299216590452459233562642920123055978471365092000347562228787318105538018723376505390423730687522026043802357456368003656219942603097205774742385485995835519133581552096067468551713114231926639878045212204590071768

n = N

print("Factorisation de n ...")

factors = factorint(n)
print(f"- Factorisation réussie ! {factors=}")
p, q = factors.keys()


print("Calcul de phi ...")

phi_n = (p - 1) * (q - 1)

print(f"- Phi calculé : {phi_n=}")

print("Calcul de d ...")

e = 3
d = pow(e, -1, phi_n)

print(f"- d calculé : {phi_n=}")

print("Déchiffrage de c ...")

c = C
m = pow(c, d, n)
print(f"\nMessage déchiffré :\n{m}")
```

Après tentative, une factorisation ne donne rien rapidement, on se dirige donc vers une autre faille

## Attaque par racine cubique

On peut essayer d'utiliser cette faille qui fonctionne si $m^e < n$ car dans ces cas, le $mod(n)$ n'aura rien changé.

Ainsi, essayons cet algorithme :

```py
from gmpy2 import iroot

C = 6317668510138686569655374990729607736156413707292408158720036346854309670467296052918552527575331589363290061240725095262980389263184520673983411112154423282089471021996509038472493779143273789325774414352608726252566350689111876373836913240644190951995980896093509379920452743478551321978067299216590452459233562642920123055978471365092000347562228787318105538018723376505390423730687522026043802357456368003656219942603097205774742385485995835519133581552096067468551713114231926639878045212204590071768

message, r = iroot(C, 3)
if r:
    print(f"\nMessage déchiffré :\n{message}")
else:
    print("Impossible")
```

# Résolution

Il se trouve que l'attaque par racine cubique fonctionne !
On peut donc l'utiliser et récupérer le message

```py
from gmpy2 import iroot

C = 6317668510138686569655374990729607736156413707292408158720036346854309670467296052918552527575331589363290061240725095262980389263184520673983411112154423282089471021996509038472493779143273789325774414352608726252566350689111876373836913240644190951995980896093509379920452743478551321978067299216590452459233562642920123055978471365092000347562228787318105538018723376505390423730687522026043802357456368003656219942603097205774742385485995835519133581552096067468551713114231926639878045212204590071768

message, exact = iroot(C, 3)
print(iroot(C, 3))
if exact:
    print(f"Message déchiffré : {message}")
else:
    print("L'attaque par racine cubique ne fonctionne pas.")

m_bytes = message.to_bytes((message.bit_length() + 7) // 8, "little")

message = m_bytes.decode("utf-8")
print(f"{message}")
```

```
FCSC{30f7c4b2fa7f0fb48bfbd9bbd413491c0a6da660764961b862fe38a83b4bc00f}
```